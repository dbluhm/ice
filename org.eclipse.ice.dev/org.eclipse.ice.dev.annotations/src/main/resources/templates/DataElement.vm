#if($package)
package $package;
#end

import java.io.Serializable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.AccessLevel;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.NonNull;
import lombok.Setter;

#imports

/**
 * This is an implementation of $interface that satisfies the dependencies of
 * the @DataElement Annotation and was auto-generated by the ICE Framework.
 */
@Data
@NoArgsConstructor
@JsonAutoDetect(
	fieldVisibility = Visibility.ANY,
	getterVisibility = Visibility.NONE,
	isGetterVisibility = Visibility.NONE,
	setterVisibility = Visibility.NONE
)
@JsonIgnoreProperties(ignoreUnknown = true)
public class ${class} implements ${interface}, Serializable {

	/**
	 * Logging tool
	 */
	private static final Logger logger = LoggerFactory.getLogger(${class}.class);
	#foreach($field in $fields)

		#fielddoc
		#nonnull($tab, $esc.newline)
		#if(!${field.Getter} || ${field.VarNameDifferent})
	@Getter(AccessLevel.NONE)
		#end
		#if(!${field.Setter} || ${field.VarNameDifferent})
	@Setter(AccessLevel.NONE)
		#end
		#fielddecl
	#end
	#foreach($field in ${fields.Constants})

		#fielddoc
		#fielddecl
	#end

	#foreach($field in ${fields.VarNamesDiffer})
		#if(${field.Getter})
	/**
	 * Get ${field.VarName}.
	 * @return ${field.Name}
	 */
	public #fieldtype ${field.GetterName}() {
		return ${field.VarName};
	}
		#end
		#if(${field.Setter})
	/**
	 * Set ${field.VarName}.
	 * @param ${field.VarName} new value for ${field.Name}.
	 */
	public void set${field.NameForMethod}(#fieldparametertype ${field.VarName}) {
		this.${field.VarName} = ${field.VarName};
	}
		#end
	#end

	/**
	 * All args constructor for $class.
	 *
	 * Used in JSON Deserialization.
	#foreach($field in $fields)
	 * @param ${field.VarName} {@code #fieldtype} for field ${field.VarName}
	#end
	 */
	@JsonCreator
	public $class(
	#foreach($field in $fields)
		@JsonProperty("${field.VarName}") #fieldparametertype ${field.VarName}#if($foreach.hasNext),#end
	#end
	) {
		#foreach($field in $fields)
		this.${field.VarName} = ${field.VarName};
		#end
	}

	/**
	 * Copy constructor for $class.
	 * @param other Instance of $class to copy
	 */
	public $class($interface other) {
		copy(other);
	}

	/**
	 * This operation clones the object. Note that it differs from the base class
	 * implementation in that it will return null if it cannot create the clone to
	 * promote fast failure. See {@link java.lang.Object#clone()};
	 */
	@Override
	public Object clone() {
		try {
			// Call the copy constructor to create the clone.
			return new $class(this);
		} catch (Exception e) {
			logger.error("Unable to clone $class!", e);
			return null;
		}
	}

	/**
	 * Copy the contents of another element into this element.
	 * @param element the element to copy
	 */
	@Override
	public void copy(@NonNull $interface element) {
		#foreach($field in $fields)
			#if($field.Getter)
		this.${field.VarName} = element.${field.GetterName}();
			#end
		#end
	}

	/**
	 * This function checks deep equality of DataElements to see if all members are
	 * equal ("match") with the exception of fields with match set to false (such
	 * as an automatically generated UUID). This is important for checking if two
	 * objects were generated separately but are otherwise equal.
	 *
	 * @param o the other element to compare
	 * @return true if all members of the element except excluded fields match
	 *         this element.
	 */
	@Override
	public boolean matches(Object o) {
		boolean retval = false;

		// Outer check for null comparisons
		if (o != null) {
			// Next check for shallow comparison
			if (this != o) {
				if (o instanceof $class) {
					$class other = ($class) o;

					// Separate boolean checks used to enable better catching
					// by debuggers.
					#foreach($field in ${fields.Match})

					// Matching ${field.VarName}
					boolean ${field.VarName}Match =
					#if(${field.Nullable})
						this.${field.VarName} == null ?
							this.${field.VarName} == other.${field.VarName} :
							this.${field.VarName}.equals(other.${field.VarName});
					#elseif(${field.Primitive})
						this.${field.VarName} == other.${field.VarName};
					#else
						this.${field.VarName}.equals(other.${field.VarName});
					#end## if nullable
					#end## foreach

					retval =
					#@settab(6)
						#foreach($field in ${fields.Match})#@nonewline
						${field.VarName}Match#if($foreach.hasNext) &&#if($foreach.count % 3 == 0)$esc.newline#else #end#end
						#end#end;
					#end
				}
			} else {
				// This should be true if they are the same because the deep comparison is
				// performed otherwise.
				retval = true;
			}
		}
		return retval;
	}

	/**
	 * This operation serializes the data element to a string in verified JSON.
	 *
	 * @return a JSON string describing the element
	 */
	@Override
	public String toJson() {
		String value = null;
		// Convert to json using Jackson
		ObjectMapper mapper = new ObjectMapper();
		try {
			value = mapper.writerWithDefaultPrettyPrinter().writeValueAsString(this);
		} catch (JsonProcessingException e) {
			logger.error("Unable to write DataElement to string!", e);
		}

		return value;
	}

	/**
	 * This operation deserializes a valid JSON string and tries to load it into the
	 * object.
	 *
	 * @param jsonDataElement the contents of this data element as JSON
	 */
	@Override
	public $interface fromJson(final String jsonDataElement) {
		// Load the data from the string with Jackson.
		ObjectMapper mapper = new ObjectMapper();

		try {
			copy(mapper.readValue(jsonDataElement, ${class}.class));
		} catch (JsonProcessingException e) {
			logger.error("Unable to read DataElement from string!", e);
		}

		return this;
	}
}